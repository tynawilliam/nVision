(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.HalkaState = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function useMountEffect(effect) {
    React.useEffect(effect, []);
  }

  function useIsJustMountedState() {
    var isJustMounted = React.useRef(true);

    if (isJustMounted.current) {
      isJustMounted.current = false;
      return true;
    }

    return isJustMounted.current;
  }

  function useUpdateOnlyEffect(effect, dependencies) {
    var isJustMounted = useIsJustMountedState();
    React.useEffect(function () {
      if (!isJustMounted) {
        return effect();
      }
    }, dependencies);
  }

  function useForceUpdate() {
    var triggerUpdate = React.useState({})[1];
    return React.useCallback(function () {
      triggerUpdate({});
    }, []);
  } // typescript has issues with unique symbol type for Set and Record
  function createStore(initialState) {
    var listenerKeys = new Set();
    var listeners = {};
    var store = {
      state: typeof initialState === 'function' ? initialState() : initialState,
      getState: function getState() {
        return this.state;
      }
    };

    function updater(arg) {
      var newState;

      if (typeof arg === 'function') {
        newState = arg(store.state);
      } else {
        newState = arg;
      }

      store.state = newState;
      listenerKeys.forEach(function (key) {
        var listener = listeners[key];
        var nextSlice = listener.selector(store.state);

        if (!listener.equalityCheck(listener.prevSlice, nextSlice)) {
          listener.triggerUpdate();
        }
      });
    }

    var defaultSelector = function defaultSelector(state) {
      return state;
    };

    var defaultEqualityCheck = function defaultEqualityCheck(prevSlice, nextSlice) {
      return prevSlice === nextSlice;
    };

    var useStore = function useStore(selector, equalityCheck) {
      if (selector === void 0) {
        selector = defaultSelector;
      }

      if (equalityCheck === void 0) {
        equalityCheck = defaultEqualityCheck;
      }

      var state = store.getState();
      var currentSlice = selector(state);
      var listenerKeyRef = React.useRef(Symbol('listener'));
      var triggerUpdate = useForceUpdate();
      useMountEffect(function () {
        var listenerKey = listenerKeyRef.current;
        listenerKeys.add(listenerKey);
        listeners[listenerKey] = {
          triggerUpdate: triggerUpdate,
          prevSlice: currentSlice,
          selector: selector,
          equalityCheck: equalityCheck
        };

        if (!equalityCheck(currentSlice, selector(store.getState()))) {
          triggerUpdate();
        }

        return function () {
          listenerKeys["delete"](listenerKey);
          delete listeners[listenerKey];
        };
      });
      useUpdateOnlyEffect(function () {
        var listenerKey = listenerKeyRef.current;
        listeners[listenerKey].selector = selector;
      }, [selector]);
      useUpdateOnlyEffect(function () {
        var listenerKey = listenerKeyRef.current;
        listeners[listenerKey].equalityCheck = equalityCheck;

        if (!equalityCheck(currentSlice, selector(store.getState()))) {
          triggerUpdate();
        }
      }, [equalityCheck]);
      useUpdateOnlyEffect(function () {
        var listenerKey = listenerKeyRef.current;
        listeners[listenerKey].prevSlice = currentSlice;
      });
      return currentSlice;
    };

    useStore.set = updater;
    useStore.get = store.getState.bind(store);
    return useStore;
  }

  exports.createStore = createStore;

})));
//# sourceMappingURL=index.umd.js.map
