import React from 'react';

function useMountEffect(effect) {
  React.useEffect(effect, []);
}

function useIsJustMountedState() {
  const isJustMounted = React.useRef(true);

  if (isJustMounted.current) {
    isJustMounted.current = false;
    return true;
  }

  return isJustMounted.current;
}

function useUpdateOnlyEffect(effect, dependencies) {
  const isJustMounted = useIsJustMountedState();
  React.useEffect(() => {
    if (!isJustMounted) {
      return effect();
    }
  }, dependencies);
}

function useForceUpdate() {
  const triggerUpdate = React.useState({})[1];
  return React.useCallback(() => {
    triggerUpdate({});
  }, []);
} // typescript has issues with unique symbol type for Set and Record
function createStore(initialState) {
  const listenerKeys = new Set();
  let listeners = {};
  const store = {
    state: typeof initialState === 'function' ? initialState() : initialState,

    getState() {
      return this.state;
    }

  };

  function updater(arg) {
    let newState;

    if (typeof arg === 'function') {
      newState = arg(store.state);
    } else {
      newState = arg;
    }

    store.state = newState;
    listenerKeys.forEach(key => {
      const listener = listeners[key];
      const nextSlice = listener.selector(store.state);

      if (!listener.equalityCheck(listener.prevSlice, nextSlice)) {
        listener.triggerUpdate();
      }
    });
  }

  const defaultSelector = state => state;

  const defaultEqualityCheck = (prevSlice, nextSlice) => prevSlice === nextSlice;

  const useStore = (selector = defaultSelector, equalityCheck = defaultEqualityCheck) => {
    const state = store.getState();
    const currentSlice = selector(state);
    const listenerKeyRef = React.useRef(Symbol('listener'));
    const triggerUpdate = useForceUpdate();
    useMountEffect(() => {
      const listenerKey = listenerKeyRef.current;
      listenerKeys.add(listenerKey);
      listeners[listenerKey] = {
        triggerUpdate,
        prevSlice: currentSlice,
        selector,
        equalityCheck
      };

      if (!equalityCheck(currentSlice, selector(store.getState()))) {
        triggerUpdate();
      }

      return () => {
        listenerKeys.delete(listenerKey);
        delete listeners[listenerKey];
      };
    });
    useUpdateOnlyEffect(() => {
      const listenerKey = listenerKeyRef.current;
      listeners[listenerKey].selector = selector;
    }, [selector]);
    useUpdateOnlyEffect(() => {
      const listenerKey = listenerKeyRef.current;
      listeners[listenerKey].equalityCheck = equalityCheck;

      if (!equalityCheck(currentSlice, selector(store.getState()))) {
        triggerUpdate();
      }
    }, [equalityCheck]);
    useUpdateOnlyEffect(() => {
      const listenerKey = listenerKeyRef.current;
      listeners[listenerKey].prevSlice = currentSlice;
    });
    return currentSlice;
  };

  useStore.set = updater;
  useStore.get = store.getState.bind(store);
  return useStore;
}

export { createStore };
//# sourceMappingURL=index.modern.js.map
